<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mobile Manipulator Paper Reading | Xiang's Blog</title><meta name="description" content="Mobile Manipulator Paper Reading关于在读Mobile Manipulator Door Pushing Task中遇到的一些paper的note 主要关于coordinated motion planning的一些相关方法。 DifficultiesFor door Opening Task: How to represent a state in this doo"><meta name="keywords" content="Mobile Manipulator,motion planning"><meta name="author" content="阿翔"><meta name="copyright" content="阿翔"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/assets/Radiohead.jpg"><link rel="canonical" href="http://canva4.github.io/2021/03/05/Mobile-Manipulator-Paper-Reading/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Mobile Manipulator Paper Reading"><meta property="og:url" content="http://canva4.github.io/2021/03/05/Mobile-Manipulator-Paper-Reading/"><meta property="og:site_name" content="Xiang's Blog"><meta property="og:description" content="Mobile Manipulator Paper Reading关于在读Mobile Manipulator Door Pushing Task中遇到的一些paper的note 主要关于coordinated motion planning的一些相关方法。 DifficultiesFor door Opening Task: How to represent a state in this doo"><meta property="og:image" content="https://i.loli.net/2021/04/04/oFaeZwq1MDbLPiO.png"><meta property="article:published_time" content="2021-03-05T12:11:54.000Z"><meta property="article:modified_time" content="2021-04-04T10:09:52.900Z"><meta name="twitter:card" content="summary"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"limitCount":50,"languages":{"author":"作者: 阿翔","link":"链接: ","source":"来源: Xiang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-04-04 18:09:52'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="alternate" href="/atom.xml" title="Xiang's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://i.loli.net/2020/09/06/hCrie9pkUMQRzsg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mobile-Manipulator-Paper-Reading"><span class="toc-number">1.</span> <span class="toc-text">Mobile Manipulator Paper Reading</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Difficulties"><span class="toc-number">1.1.</span> <span class="toc-text">Difficulties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#For-door-Opening-Task"><span class="toc-number">1.1.1.</span> <span class="toc-text">For door Opening Task:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#For-Coordinate-Motion-Planning"><span class="toc-number">1.1.2.</span> <span class="toc-text">For Coordinate Motion Planning</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-Summary"><span class="toc-number">1.2.</span> <span class="toc-text">Task Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Paper-List"><span class="toc-number">2.</span> <span class="toc-text">Paper List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Planning-for-Autonomous-Door-Opening-with-a-Mobile-Manipulator"><span class="toc-number">3.</span> <span class="toc-text">Planning for Autonomous Door Opening with a Mobile Manipulator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">3.1.</span> <span class="toc-text">Introduction:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Related-Work"><span class="toc-number">3.1.1.</span> <span class="toc-text">Related Work:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hardware"><span class="toc-number">3.2.</span> <span class="toc-text">Hardware</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Architecture"><span class="toc-number">3.3.</span> <span class="toc-text">System Architecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coordinated-Arm-Base-Motion-Planning"><span class="toc-number">3.4.</span> <span class="toc-text">Coordinated Arm-Base Motion Planning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-Representation"><span class="toc-number">3.4.1.</span> <span class="toc-text">Graph Representation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#State-Variables"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">State Variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transitions"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">Transitions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cost-Function"><span class="toc-number">3.4.2.</span> <span class="toc-text">Cost Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-Costmap"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">2D Costmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arm-based-cost"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">Arm-based cost</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-Search"><span class="toc-number">3.4.3.</span> <span class="toc-text">Graph Search</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation"><span class="toc-number">3.5.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">3.6.</span> <span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Finding-Locally-Optimal-Collision-Free-Trajectories-with-Sequential-Convex-Optimization-trajopt"><span class="toc-number">4.</span> <span class="toc-text">Finding Locally Optimal, Collision-Free Trajectories with Sequential Convex Optimization(trajopt)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-1"><span class="toc-number">4.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Related-Work-1"><span class="toc-number">4.2.</span> <span class="toc-text">Related Work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequential-Convex-Optimization"><span class="toc-number">4.3.</span> <span class="toc-text">Sequential Convex Optimization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Discrete-Time-No-Collisions-Constraint"><span class="toc-number">4.4.</span> <span class="toc-text">Discrete-Time No-Collisions Constraint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENSURING-CONTINUOUS-TIME-SAFETY"><span class="toc-number">4.5.</span> <span class="toc-text">ENSURING CONTINUOUS-TIME SAFETY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-1"><span class="toc-number">4.6.</span> <span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Safe-and-Coordinated-Hierarchical-Receding-Horizon-Control-for-Mobile-Manipulators-HRHC"><span class="toc-number">5.</span> <span class="toc-text">Safe and Coordinated Hierarchical Receding Horizon Control for Mobile Manipulators(HRHC)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-2"><span class="toc-number">5.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-Formulation"><span class="toc-number">5.2.</span> <span class="toc-text">Problem Formulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hierarchical-Receding-Horizon-Control-HRHC"><span class="toc-number">5.3.</span> <span class="toc-text">Hierarchical Receding Horizon Control (HRHC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-2"><span class="toc-number">5.4.</span> <span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Perceptive-Model-Predictive-Control-for-Continuous-Mobile-Manipulation"><span class="toc-number">6.</span> <span class="toc-text">Perceptive Model Predictive Control for Continuous Mobile Manipulation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-3"><span class="toc-number">6.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-Predictive-Control-MPC"><span class="toc-number">6.2.</span> <span class="toc-text">Model Predictive Control(MPC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-3"><span class="toc-number">6.3.</span> <span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CHOMP-Gradient-optimization-techniques-for-efficient-motion-planning"><span class="toc-number">7.</span> <span class="toc-text">CHOMP: Gradient optimization techniques for efficient motion planning</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-4"><span class="toc-number">7.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#THE-CHOMP-ALGORITHM"><span class="toc-number">7.2.</span> <span class="toc-text">THE CHOMP ALGORITHM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Covariant-gradient-descent"><span class="toc-number">7.2.1.</span> <span class="toc-text">Covariant gradient descent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Understanding-the-Updata-Rule"><span class="toc-number">7.2.2.</span> <span class="toc-text">Understanding the Updata Rule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Obstacles-and-distance-fields"><span class="toc-number">7.2.3.</span> <span class="toc-text">Obstacles and distance fields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-an-obstacle-potential"><span class="toc-number">7.2.4.</span> <span class="toc-text">Defining an obstacle potential</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smooth-Projection-for-Joint-Limits"><span class="toc-number">7.2.5.</span> <span class="toc-text">Smooth Projection for Joint Limits</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Experiments-on-Robotic-Arm"><span class="toc-number">7.3.</span> <span class="toc-text">Experiments on Robotic Arm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-4"><span class="toc-number">7.4.</span> <span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STOMP-Stochastic-trajectory-optimization-for-motion-planning"><span class="toc-number">8.</span> <span class="toc-text">STOMP: Stochastic trajectory optimization for motion planning</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2021/04/04/oFaeZwq1MDbLPiO.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Xiang's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Mobile Manipulator Paper Reading</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-05T12:11:54.000Z" title="发表于 2021-03-05 20:11:54">2021-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T10:09:52.900Z" title="更新于 2021-04-04 18:09:52">2021-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Works/">Works</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Mobile-Manipulator-Paper-Reading"><a href="#Mobile-Manipulator-Paper-Reading" class="headerlink" title="Mobile Manipulator Paper Reading"></a>Mobile Manipulator Paper Reading</h1><p><del>关于在读Mobile Manipulator Door Pushing Task中遇到的一些paper的note</del></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>主要关于coordinated motion planning的一些相关方法。</p>
<h2 id="Difficulties"><a href="#Difficulties" class="headerlink" title="Difficulties"></a>Difficulties</h2><h3 id="For-door-Opening-Task"><a href="#For-door-Opening-Task" class="headerlink" title="For door Opening Task:"></a>For door Opening Task:</h3><ol>
<li>How to represent a state in this door opening task? When this representation has high dimension, it’s hard to find a solution.</li>
<li>The optimal position or state to open the door is unkown.</li>
<li>Door open problem itself need to consider a lot of stuff e.g. collide, reachability…</li>
<li>identified the position of the door</li>
</ol>
<h3 id="For-Coordinate-Motion-Planning"><a href="#For-Coordinate-Motion-Planning" class="headerlink" title="For Coordinate Motion Planning"></a>For Coordinate Motion Planning</h3><ol>
<li>base need to consider dynamics! Especially for non-omnidirectional base.</li>
<li>how to desgin the <strong>State</strong> that represent the base in this motion planning task.</li>
</ol>
<h2 id="Task-Summary"><a href="#Task-Summary" class="headerlink" title="Task Summary"></a>Task Summary</h2><p>TODO: </p>
<ol>
<li>Pybullet &amp; Gazebo <a target="_blank" rel="noopener" href="https://github.com/oscar-lima/pybullet_ros">https://github.com/oscar-lima/pybullet_ros</a></li>
<li></li>
</ol>
<p>Reading List:</p>
<ol>
<li>Receding horizon control (RHC), also known as model predictive control (MPC) <a target="_blank" rel="noopener" href="https://web.stanford.edu/~boyd/papers/code_gen_rhc.html">https://web.stanford.edu/~boyd/papers/code_gen_rhc.html</a></li>
<li></li>
</ol>
<p>Paper1 </p>
<ol>
<li>impedence control</li>
<li>reactive controller</li>
<li>compliant control</li>
<li>constrained planner</li>
<li>graph Search<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54510444">https://zhuanlan.zhihu.com/p/54510444</a></li>
</ol>
</li>
</ol>
<p>Paper2</p>
<ol>
<li>support mapping</li>
</ol>
<h1 id="Paper-List"><a href="#Paper-List" class="headerlink" title="Paper List"></a>Paper List</h1><ol>
<li>Planning for Autonomous Door Opening with a Mobile Manipulator 2010</li>
<li>Finding Locally Optimal, Collision-Free Trajectories with Sequential Convex Optimization 2013</li>
<li>Safe and Coordinated Hierarchical Receding Horizon Control for Mobile Manipulators 2020</li>
<li>Perceptive Model Predictive Control for Continuous Mobile Manipulation 2020</li>
<li>CHOMP: Gradient optimization techniques for efficient motion planning. 2009</li>
<li>STOMP: Stochastic trajectory optimization for motion planning. 2011</li>
</ol>
<h1 id="Planning-for-Autonomous-Door-Opening-with-a-Mobile-Manipulator"><a href="#Planning-for-Autonomous-Door-Opening-with-a-Mobile-Manipulator" class="headerlink" title="Planning for Autonomous Door Opening with a Mobile Manipulator"></a>Planning for Autonomous Door Opening with a Mobile Manipulator</h1><p>Author: Sachin Chitta er al  <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~maxim/files/doorplanner_icra10.pdf">Paper Link</a></p>
<p>Journal/Conference: ICRA 2010</p>
<p><strong>本文核心：找到一了一种相对有更低dimension的state representation（graph representation），这样可以使用一些图上的搜索算法（planning method）生成一个trajectory，从而达到motion planning的目的。</strong></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><p>对于door opening这个问题本身就存在很多困难</p>
<ol>
<li><p>it is hard to identify precisely the position and size of doors and handles</p>
</li>
<li><p>it is hard to autonomously compute the right approach to grasping and manipulating the handle</p>
</li>
<li><p>it is hard to compute a coordinated arm-base motion that opens the door wide enough for the robot to navigate through it.</p>
</li>
</ol>
<p>本文主要针对解决第三个问题，即如何plan出一个手臂和底盘相互协作来开门的动作。对于第三个问题，如果简单的使用规定好的基于先验知识的motion来开门，会导致无法适应多种多样的门。而如果是用plan的方法，opening a door using a mobile manipulation platform typically involves tight coordination in between the motion of the base and the motion of the arm. This makes the problem high-dimensional and thus hard to plan for.</p>
<p>所以这篇paper的主要工作就是提出了一种对于机器人state的低维graph-based representation，在保证这种representation可以包含足够的信息（环境障碍物信息，机械臂reachability的信息等）的前提下，这种低维的、graph-based representation就可以使用在graph上的一些启发式搜索方法，把原有问题的planning变为一个在图上的搜索问题，使用一些例如A*的方法来生成一个基于这个低维state representation的trajectory，这就完成了上面所述的problem 3。因为这个低维state representation也包含了足够的信息，可以计算出真正所需的底盘和arm的motion.</p>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work:"></a>Related Work:</h3><p>一些方法使用例如impedence control、reactive controller、constrained planner等方法，其问题是没有使用planning的方法，而另一些使用planning的方法有没有考虑到碰撞的问题，而且以上方法只考虑了pushing, no pulling!</p>
<p>作者这篇paper提出的planning方法：既包含了pushing and pulling；而且还考虑了如何避免碰撞。 </p>
<h2 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h2><p>使用的机器人PR2。全向底盘+7dof机械臂，主要使用的sensor为两个laser，一个用来为底盘提供周围的2D representation；另一个用来获取机器人前方的3D信息（如门的信息等）。</p>
<p>这里还提到了7dof这种redundant dof的好处，This proves useful in extending the usable workspace of the arm, especially in cluttered environments.</p>
<h2 id="System-Architecture"><a href="#System-Architecture" class="headerlink" title="System Architecture"></a>System Architecture</h2><p>作者将整个door opening问题分为了两个子问题：</p>
<ol>
<li>检测门和门把手  —-&gt; 使用现成的方法 见**[Reference 1]**  该方法需要知道门的一些先验信息，该方法的输出为：门和门把手以及hinge的位置信息。NOTE：门的旋转方向为一个先验知识！</li>
<li>规划和执行开门的动作</li>
</ol>
<p>对于第二个子问题即：<strong>规划和执行开门的动作</strong>，作者又将其进一步的分为了一些列子问题或者说是一个解决这个问题的流程：</p>
<ol>
<li>往门的方向移动机器人，目标是可以接触到门把手</li>
<li>伸出手臂抓住门把手，轻微的unlatch（这个过程底盘不动）</li>
<li>由模型决定（先验知识）决定这个门是应该拉，还是应该推；并轻微的拉开or推开门</li>
<li>规划一个手臂和底盘协同的motion来开门。这个规划的动作是手臂与底盘配合着来的，而且考虑了避免碰撞</li>
<li>如果是使用pulling的方法，检测门和手臂的碰撞。如果可能会发生碰撞，就会换一边，转而抓住门把手的另一侧。（这个动作中底盘不动）</li>
<li>如果没有完全打开门，则之后基于5继续执行一个pushing开门的planning</li>
</ol>
<p>这6个子问题又可以分为两类，</p>
<ul>
<li>the act of reaching out and grasping the handle and opening the door slightly （1~3）</li>
<li>the act of opening the door using a coordinated motion of the base and the arm of the robot. （3~6）</li>
</ul>
<p>前一个是使用现有的解决方案：**[Reference 2]**</p>
<p>本文主要是解决第二个问题，即如何生成一个base &amp; arm 协同开门的motion。</p>
<p>简单的分析一下这个子问题，执行一些列开门动作时，有一个重要的约束，即：gripper必须要抓着门把手。</p>
<p>另外一个难点就是：<strong>goal position是不确定的！在执行动作的时候，并没有一个确定的最优的goal，而是仅仅有一个要找到能打开门的position的这个目标。</strong></p>
<p>如果想实现一个对于全部configuration space的planner（底盘运动+7 dof arm），这就需要一个constrained planner，而这类constrained planner在处理高纬度有约束的情况下是非常困难的。</p>
<p>所有作者有了本文的核心方法，也是main contribution，即：设计了一个lower-dimensional graph-based representation，基于这个就可以比较轻松的找到一个合理的motion了。</p>
<p><strong>整体思路：</strong></p>
<ul>
<li>将高维的问题化简为先在平面（即只考虑底盘）上规划，找到一个手臂可以接触到门把手且比较合理的位置</li>
<li>之后使用IK计算arm的trajectory，并与base一起运动，这其中要保持手臂可以一直接触到门把手这个约束</li>
</ul>
<p>本质上就是将三维的规划问题变为了一个2D 规划+IK 的问题。</p>
<h2 id="Coordinated-Arm-Base-Motion-Planning"><a href="#Coordinated-Arm-Base-Motion-Planning" class="headerlink" title="Coordinated Arm-Base Motion Planning"></a>Coordinated Arm-Base Motion Planning</h2><p>整个Coordinated Arm-Base Motion Planning包含如何构建一个低维的Graph Representation，如何在这个graph上搜索，基于这个结果如何生成Coordinated Arm-Base Motion。</p>
<p>再次明确一下这个planning的目标：</p>
<p>Note that the final goal for the base motion is not specified. The goal for the entire task, however, is to open the door.</p>
<h3 id="Graph-Representation"><a href="#Graph-Representation" class="headerlink" title="Graph Representation"></a>Graph Representation</h3><p>总结来说，就是要将原问题变为一个在图上的搜索问题。所以需要定义好每个state是什么，state之间的转移情况，一起每个state的cost。</p>
<h4 id="State-Variables"><a href="#State-Variables" class="headerlink" title="State Variables"></a>State Variables</h4><p>明确state Variables: $s=(x,y,\theta,d)$</p>
<p>x,y 为底盘的位置，$\theta$为base的朝向。如果只含有这三个，显然无法包含我们的goal的信息，所以需要额外增加state的维度来包含这个信息，作者增加的额外一维即为d，即：using a single binary variable that we call <em>door interval</em>.</p>
<p>下图为一个关于 <em>door interval</em>的解释。</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/06/sA3WIEgRmvS8foV.png" alt="image-20210306112413167" style="zoom:67%;" />

<p>所有门可能到达的角度（前提是不与机器人发生碰撞）被分为了两个区间，如果门处于这两个区间中的一个，那么d这个变量就是那个对应的区间。可见这个d就表明了目前门所在的大致位置。</p>
<p>设置一开始门关闭的时候位于intervel 0，如果门移动到了intervel 1，那么就完成了我们open的目标。</p>
<p>并且基于这个$s=(x,y,\theta,d)$，也可以计算出可行的门打开的角度（因为要满足机器人抓住门这个约束），即这些角度就是机器人手可以到达的地方所对应的角度，而且不会发生碰撞，对于每一个state s这一系列角度的集合被称为：$\Lambda(s)$。作者对这个角度集合做了分度为1度的离散化。这种离散化的好处是极大的减小了搜索空间。</p>
<p>此时就可以定义一个state-space了，这个state-space只包含有非空$\Lambda(s)$的s。</p>
<p>所以用定义好的state来描述目标就是：A state s is a goal state if it belongs to interval 1 and if Λ(s) contains an angle that is closer than a threshold $\delta_d$ from the fully open door angle.</p>
<p>下面就定义state之间如何进行Transitions。</p>
<h4 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h4><p>作者在构建Transitions的时候，使用了lattice-based planning representation的方法**[Reference 3&amp;4]**。</p>
<p>这种lattice-based representation是对于C-space的一种离散化，将c-sapce离散化为了一些列state，并将这些state用一些可行的、short-term的action相连接。下图为一个示例：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/06/l5xoX2WeVtYAhQb.png" alt="image-20210306114533040"></p>
<p>这种lattices就将motion planning变为了一个graph search的问题。During the search (planning), these actions are translated and rotated for each state encountered by search, and the successors of the state are computed as the corresponding end configurations of these actions. The planner also checks all actions against collisions by checking the footprint of the action (constructed from the footprint of the robot) against the map of the environment.</p>
<p>这里要额外明确好如何定义s中的d的transition。</p>
<ul>
<li>如果$d(s)\ne d(s^{‘})$, 想要发生transition必须有：$\Lambda(s)\cap \Lambda(s^{‘}) \neq \varnothing$且x,y,θ必须相等。也就意味着：the robot is out of the way of the door and can reach the door handle</li>
<li>对于$d(s)=d(s^{‘})$，就相对简单了，只需要as the robot executes any action in our lattice, it will be able to maintain its gripper on the door handle.</li>
</ul>
<h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3><p>planner使用的cost function是一个包含了2D cost（表示了base到最近obstacle的距离）和一个基于arm位姿的cost（包含了该位姿是不是出于一个比较舒服的，即：每个joint的position不接近limit的位置）</p>
<h4 id="2D-Costmap"><a href="#2D-Costmap" class="headerlink" title="2D Costmap"></a>2D Costmap</h4><p>将三维投影至2D来构建一个2D costmap，具体方法见：**[reference 5]**。其结果代表了离最近obstacles的距离</p>
<h4 id="Arm-based-cost"><a href="#Arm-based-cost" class="headerlink" title="Arm-based cost"></a>Arm-based cost</h4><p>其表示了每个joint的position不接近limit的位置，具体计算过程见paper</p>
<h3 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h3><p>使用Anytime Repairing A* (ARA*)算法见**[reference 8]**。值得注意的是，这个方法相比于A star算法，额外考虑了时间因素，所以有时无法获得最优解（不是最低的cost），但仍然给出了一个关于该解与最优解关系的下界。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Arm planning Using: <strong>[Reference 7]</strong></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Laser-based perception for door and handle identification 2009</li>
<li>Autonomous Door Opening and Plugging In using a Personal Robot 2010</li>
<li>Generating near minimal spanning control sets for constrained motion planning in discrete state spaces 2005</li>
<li>Planning long dynamicallyfeasible maneuvers for autonomous vehicles 2009</li>
<li>The office marathon: Robust navigation in an indoor office environment 2010</li>
<li>A formal basis for the heuristic determination of minimum cost paths（A star算法）</li>
<li>Combining Planning Techniques for Manipulation Using Real-time Perception 2010</li>
<li>ARA*: Anytime A* with provable bounds on sub-optimality  2003</li>
</ol>
<h1 id="Finding-Locally-Optimal-Collision-Free-Trajectories-with-Sequential-Convex-Optimization-trajopt"><a href="#Finding-Locally-Optimal-Collision-Free-Trajectories-with-Sequential-Convex-Optimization-trajopt" class="headerlink" title="Finding Locally Optimal, Collision-Free Trajectories with Sequential Convex Optimization(trajopt)"></a>Finding Locally Optimal, Collision-Free Trajectories with Sequential Convex Optimization(trajopt)</h1><p>Author: John Schulman er al </p>
<p>Journal/Conference: </p>
<p><strong>本文核心：本文本质来讲是提出了一种进行机器人motion planning的考虑了碰撞的trajectory optimization方法。</strong></p>
<ul>
<li>使用了sequential convex optimization procedure（一个原本非凸的问题，变为顺序的解一系列凸的子问题）</li>
<li>设计了一种no-collisions constraint that directly considers continuous-time safety，与上一点结合就可与解决许多motion planning方面的问题</li>
</ul>
<h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>此note的第一篇paper给出了一种生成motion trajectory的方法，而本文的方法更倾向于优化这些已经生成好的trajectory，即：Trajectory optimization algorithms。Trajectory optimization algorithms在机器人的motion planning领域内起到了以下作用：</p>
<ul>
<li>they can be used to smooth and shorten trajectories generated by some other method.</li>
<li>they can be used to plan from scratch: one initializes with a trajectory that contains collisions and perhaps violates constraints, and one hopes that the optimization converges to a high-quality trajectory satisfying constraints.</li>
</ul>
<p>对于这motion planning的trajectory optimization方法有以下两个关键的组成部分：</p>
<ul>
<li>numerical optimization method  <strong>本文使用</strong>：sequential convex optimization，并使用$l_1$penalties来讲不等式约束和等式约束加入到objective里面</li>
<li>the method of checking for collisions and penalizing them <strong>本文使用</strong>：signed distance，并且考虑了continuous-time safety</li>
</ul>
<h2 id="Related-Work-1"><a href="#Related-Work-1" class="headerlink" title="Related Work"></a>Related Work</h2><p>一下均为一些trajectory optimization的方法。</p>
<ol>
<li>Practical methods for optimal control and estimation using nonlinear programming 2010</li>
</ol>
<p>Trajectory optimization在optimal control中的作用</p>
<ol start="2">
<li>CHOMP: Gradient optimization techniques for efficient motion planning. 2009</li>
<li>CHOMP: Covariant hamiltonian optimization for motion planning. 2010</li>
<li>STOMP: Stochastic trajectory optimization for motion planning. 2011</li>
</ol>
<h2 id="Sequential-Convex-Optimization"><a href="#Sequential-Convex-Optimization" class="headerlink" title="Sequential Convex Optimization"></a>Sequential Convex Optimization</h2><p>本质上就是将一个non-convex optimization problem变为一系列凸的问题来处理，可能无法找到optimal，但一般可以到达一个local optimal。</p>
<p>一个机器人的motion planning问题可以被定义为一个non-convex optimization problems</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/6zqDetrbaQRos92.png" alt="image-20210307160354865"></p>
<p>对于kinematic motion planning problems，状态变量x的维数应该为：T×K，T为time-step的个数，K为dof。</p>
<p>所以optimization parameters可以写为: $\theta_{1:T}$，其中$\theta_{t}$表示在时间t时刻，机器人的configuration</p>
<p>首先确定objective，这个objective的目的是：to encourage minimum-length paths, we use the sum of squared displacements</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/nZq2cLM6IgdKSXU.png" alt="image-20210307160808722"></p>
<p>对于对于不同的任务有不同的constraints，比如对于开门任务需要保证无碰撞，且end-effector一直与门把手相接触。</p>
<p>但是这个原本的优化问题仍然是非凸的，所以使用Sequential Convex Optimization来解决，本质上来就就是将原问题构建为一系列子问题，每个子问题是在当前state对于原问题的一个估计。每个subproblem的目的是generate a step $\Delta x$ 来让original problem变好一点。</p>
<p>其两个核心的部分如下：</p>
<ol>
<li>a method for constraining the step to be small, so the solution vector remains within the region where the approximations are valid  –&gt; 使用trust region，本质就是一个bound加载state变量上</li>
<li>a strategy for turning the infeasible constraints into penalties, but eventually ensuring that all of the constraint violations are driven to zero. –&gt;使用$l_1$penalties。即对于每个不等式约束，变为$|g_i(x)|^+, |x|^+=max(x,0)$；对于每个等式约束，变为$|h_i(x)|, |x|^+=|x|$；之后将这两个penalties乘以系数$\mu$加到objective上即可。</li>
</ol>
<p>整体的算法如图，大体思路就比较明确了，就是通过一次次循环增加$\mu$的值，最终使得结果满足objective，而且在迭代的子问题（由原问题通过一个近似得到，即将非线性的约束做一个一阶近似）也是一个凸的问题。更多的细节见paper</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/VlrC984m51BYPFs.png" alt="image-20210307163306993"></p>
<p>至此，已经确定了如何解这样一个优化问题，下一步就是确定constraint了。</p>
<h2 id="Discrete-Time-No-Collisions-Constraint"><a href="#Discrete-Time-No-Collisions-Constraint" class="headerlink" title="Discrete-Time No-Collisions Constraint"></a>Discrete-Time No-Collisions Constraint</h2><p>本质来讲，这个constraint就是让所有的刚体的距离都在一定范围之外。对于每一个time-step都应该满足。这个sd( , )就是文中的signed distance，本质来就是如果两个刚体没有碰撞，那么这个距离就大于0，且相聚越远值越大。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/eCXsdyTApc7wYF2.png" alt="image-20210307164102386"></p>
<p>变为penalties后为：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/7CKYS8pOlk3a2yb.png" alt="image-20210307164301748"></p>
<p>可见这样的话计算量极大，左右使用了一些方法删去了部分不可能碰撞的pair，降低了复杂度。更多关于如何高效计算signed distance和减低penalties计算复杂度方法的细节见paper。</p>
<h2 id="ENSURING-CONTINUOUS-TIME-SAFETY"><a href="#ENSURING-CONTINUOUS-TIME-SAFETY" class="headerlink" title="ENSURING CONTINUOUS-TIME SAFETY"></a>ENSURING CONTINUOUS-TIME SAFETY</h2><p>使用上面所介绍的这个No-Collisions Constraint就可以优化这个discretely-sampled trajectory，让其无碰撞。这些trajectory上的waypoints需要转变为一个continuous-time trajectory，直观的可以使用线性插值，但这种可能会导致continuous-time trajectory发生碰撞，如下图所示</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/DY6JUTgZAfFVzS5.png" alt="image-20210307165508196"></p>
<p>为了解决这个问题，引入swept-out volume需要再将penalties做一个修正，swept-out volume如下图所示，是一个当前时刻的位置与下一个时刻位置的一个convex hull</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/bf74qrlmRKeESPX.png" alt="image-20210307165956616"></p>
<p>然后将上一部分的signed distance变为如下的形式即可</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/07/XnIhZ2HbsFARQTL.png" alt="image-20210307170210716"></p>
<p>这个计算起来也比较复杂，文中有详细描述了如何简化这个的计算。</p>
<p>NOTE: 作者在implement part也说明了如何设置例如开门任务的constraint</p>
<h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>A fast and robust GJK implementation for collision detection of convex objects. 1999  关于swept-out volume</li>
</ol>
<h1 id="Safe-and-Coordinated-Hierarchical-Receding-Horizon-Control-for-Mobile-Manipulators-HRHC"><a href="#Safe-and-Coordinated-Hierarchical-Receding-Horizon-Control-for-Mobile-Manipulators-HRHC" class="headerlink" title="Safe and Coordinated Hierarchical Receding Horizon Control for Mobile Manipulators(HRHC)"></a>Safe and Coordinated Hierarchical Receding Horizon Control for Mobile Manipulators(HRHC)</h1><p>Author: Jessica Leu er al</p>
<p>Journal/Conference: American Control Conference 2020</p>
<p><strong>本文核心：本文针对的情况主要是time-varying dynamic environments</strong></p>
<h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><p>开头有一段很好的关于literature的一个简单的review，其中提到了Reference中的几篇paper，值得根据这个继续阅读。</p>
<p>以前的这些方法的问题是他们一般是基于一个static environment，对于time-varying的环境并不适用。可以进一步通过加入prior knowledge来降低计算量，但显然这种基于prior knowledge的方法的使用范围还是有限的。</p>
<p>optimization methods受高维数数据影响更少，所以更适合用于这种coordinated motion planning.</p>
<p>本篇文章的核心目标是：</p>
<ul>
<li>更高效。planning 所需时间更短</li>
<li>可让算法适用于更多的场景。</li>
</ul>
<p>算法分为：A high level motion planning module用于解决motion planning问题（求解非凸的优化问题）&amp; a low level safety controller运作在一个高频率下，保证当前的action是安全的。</p>
<h2 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h2><p>主要介绍了这两部分：</p>
<ul>
<li>Formulation ofthe motion planning optimization problem 主要说明了一些notation和使用什么样的cost function</li>
<li>Convex Feasible Set Algorithm（CFS），如何快速求解一个motion planning（non-convex problem）</li>
<li>以及如何设计constraint（Constraints formulation），保证碰撞安全的约束使用capsules（代表link）之间的距离来计算</li>
</ul>
<h2 id="Hierarchical-Receding-Horizon-Control-HRHC"><a href="#Hierarchical-Receding-Horizon-Control-HRHC" class="headerlink" title="Hierarchical Receding Horizon Control (HRHC)"></a>Hierarchical Receding Horizon Control (HRHC)</h2><p>在上层的motion planning部分主要使用CFS，额外设计了Soft constraints。即：引入松弛变量。</p>
<p>下层额外加入了Low-level safety controller，因为上层生成的无碰撞轨迹的生成时间相比于环境的变化时间较长，所以决策系统上一时刻生成的轨迹可能在此时并不适用，甚至会发生碰撞，所以需要一个更新更快的底层安全控制器来保证系统的安全性。实现起来本质是使用了一个更粗糙的碰撞检测。</p>
<h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>S. M. LaValle, Planning algorithms. Cambridge university press, 2006.</li>
<li>Search-based planning for manipulation with motion primitives 2010</li>
<li>“Optimization techniques applied to multiple manipulators for path planning and torque minimization,” 2002</li>
<li>“Local motion planning for collaborative multi-robot manipulation of deformable<br>objects,” 2015</li>
<li>“Efficient kinematic planning for mobile manipulators with nonholonomic constraints using optimal control,” 2017 <strong>VITAL</strong></li>
<li>“Stomp: Stochastic trajectory optimization for motion planning,”  2018</li>
<li>“Synthesis and stabilization of complex behaviors through online trajectory optimization,” 2012 iterative LQR</li>
</ol>
<h1 id="Perceptive-Model-Predictive-Control-for-Continuous-Mobile-Manipulation"><a href="#Perceptive-Model-Predictive-Control-for-Continuous-Mobile-Manipulation" class="headerlink" title="Perceptive Model Predictive Control for Continuous Mobile Manipulation"></a>Perceptive Model Predictive Control for Continuous Mobile Manipulation</h1><p>Author: Johannes Pankert er al</p>
<p>Journal/Conference: IROS 2020</p>
<p><strong>本文核心：本质上是一个给定预期end-effector trajectory（基于task space or Cartesian Space），产生每个关节控制量（速度）的controller；can control interaction-forces of a mobile robot without torque-controllable joints，</strong></p>
<h2 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h2><p>主要针对，Continuous manipulation task，例如檫黑板，cleaning这些workspace超出一个固定机械手的workspace.</p>
<h2 id="Model-Predictive-Control-MPC"><a href="#Model-Predictive-Control-MPC" class="headerlink" title="Model Predictive Control(MPC)"></a>Model Predictive Control(MPC)</h2><p>MPC是一种使用优化方法的controller，其考虑了约束的影响。</p>
<p><strong>Sequential Linear Quadratic Model Predictive Control(SLQ method)</strong></p>
<p>简介：本质上还是一个求解optimal Control的方法。对于系统的dynamic进行在当前state和input trajectory进行linearized。之后对于cost function做一个Quadratic approximate。之后求解出一个affine的控制策略</p>
<p>详细见Reference。</p>
<p><strong>System Model</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/19/y8Guvp79AKi5BWt.png" alt="image-20210316121642029"></p>
<p>这里的state就是底盘的位姿（twist中的translation和rotation，rotation用qua）每个arm的转角θ。</p>
<p><strong>Cost Function</strong></p>
<p>主要包含了三部分</p>
<ul>
<li>Task space tracking error：目标end effector的pose和预期pose间的差距。这个error又分为：translational error（用position vector之间的差距来计算）&amp; orientation error（用四元数计算）</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/19/oirdfCYBuy6gqGb.png" alt="image-20210316121403540"></p>
<p>end-effector pose的计算使用：Robcogen[Reference 1]，本质上就是求forward Kinematics</p>
<p>因为使用SLQ想要收敛的话，需要二阶导数项半正定，而一般forward Kinematics的二阶导未必半正定，所以使用Gauss-Newton来近似二阶导</p>
<ul>
<li>Soft Constraints:  （不等式约束）使用Relaxed Barrier Functions（RBF）</li>
<li>Collision Avoidance：本质上也是一种不等式约束，使用RBF函数。在内部函数里使用：球体来近似robot的link，并query Euclidean Signed Distance Field (ESDF)，并且额外引入cache gradients along with the signed distances，来加速计算（结果见paper的实验部分）。最终的约束如下式所示：FK为forward Kinematics。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/19/NxK6jd7mutHWz5I.png" alt="image-20210316124829922"></p>
<p>生成Euclidean Signed Distance Field (ESDF)使用Voxblox[Reference 2]。</p>
<p>Querying cached distances and gradients from a euclidean signed distance field(ESDF) 可以有更高的执行效率。</p>
<p>ESDF的细节见[Refernce 3,4]</p>
<p><strong>Task Space Admittance Control</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/19/r8UXQzthxnPo95C.png" alt="image-20210316151931284"></p>
<p>Detail: TODO</p>
<p>可以实现力的控制！但需要力传感器和给定的力的大小。</p>
<p><strong>Mechanical Stability</strong></p>
<p>额外增加了一个SLQ问题的constraint（using Zero Moment Point (ZMP)）</p>
<p>Detail: ????</p>
<h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><p>3、4是关于Euclidean Signed Distance Field (ESDF)的</p>
<ol>
<li><p>RobCoGen: A code generator for efficient kinematics and dynamics of articulated robots, based on Domain Specific Languages  2016</p>
</li>
<li><p>“Voxblox: Incremental 3D Euclidean Signed Distance Fields for onboard MAV planning,” 2017</p>
</li>
<li><p>CHOMP: Gradient optimization techniques for efficient motion planning. 2009</p>
</li>
<li><p>STOMP: Stochastic trajectory optimization for motion planning. 2011</p>
</li>
</ol>
<h1 id="CHOMP-Gradient-optimization-techniques-for-efficient-motion-planning"><a href="#CHOMP-Gradient-optimization-techniques-for-efficient-motion-planning" class="headerlink" title="CHOMP: Gradient optimization techniques for efficient motion planning"></a>CHOMP: Gradient optimization techniques for efficient motion planning</h1><p>Author: Nathan Ratliff er al</p>
<p>Journal/Conference: 2009</p>
<p><strong>本文核心：continuous path refinement  methods &amp; standalone motion planner；使用covariant gradient来优化采样得到的trajectory；基于configuration space</strong></p>
<p>Q: </p>
<ol>
<li>covariant gradient descent</li>
<li>finite differencing operator/matrix</li>
<li>functional gradient？（泛函梯度）</li>
</ol>
<h2 id="Introduction-4"><a href="#Introduction-4" class="headerlink" title="Introduction"></a>Introduction</h2><p>CHOMP的核心就是利用covariant gradient来优化采样得到的trajectory。基于sample-based methods改良而来。sample-based methods主要包含以下两个步骤：</p>
<ul>
<li>first find a feasible path（例如RRT：建树+A*搜索）</li>
<li>optimize it to remove redundant or jerky motion（RRT*等）</li>
</ul>
<p>第二个步骤实际上是一种trajectory optimization，之前比较流行的方法是：</p>
<ul>
<li>使用一种 shortcut heuristic [<strong>Reference 1</strong>]</li>
<li>或者使用elastic bands or elastic strips planning involves modeling paths as mass-spring systems [<strong>Reference 2</strong>]</li>
</ul>
<p>CHOMP(Covariant Hamiltonian Optimization for Motion Planning)的特点是：</p>
<ul>
<li>不需要提前输入一个collision-free的path（以前的方法需要），可以将一个不可行的trajectory变为一个local optimal的解</li>
<li>使用covariant gradient update rules（local optimal guarantee）</li>
</ul>
<h2 id="THE-CHOMP-ALGORITHM"><a href="#THE-CHOMP-ALGORITHM" class="headerlink" title="THE CHOMP ALGORITHM"></a>THE CHOMP ALGORITHM</h2><p>一个核心思想是：the proper use of geometrical relations, particularly as they apply to<br>inner products. 尤其在：differential geometry？</p>
<h3 id="Covariant-gradient-descent"><a href="#Covariant-gradient-descent" class="headerlink" title="Covariant gradient descent"></a>Covariant gradient descent</h3><p>Goal：find smooth, collision-free, trajectory through the <strong>configuration</strong> space between two prespecified end points</p>
<p>Cost Term:</p>
<p>包含两项：obs包含了障碍物信息（描述了离障碍物的距离）；prior: measures dynamical quantities of the robot such as smoothness and acceleration. $\xi$代表trajectory</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/oSNDJLMpj5RH13s.png" alt="image-20210328175140457"></p>
<p>目标是在每次iteration都通过最小化一个描述trajectory smoothness的function的local approximation。我们的cost就是这个function。</p>
<p>其中：<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/vhp1GsUTjziCXBF.png" alt="image-20210328180642410">，A是一个对称正定矩阵</p>
<p>在第k步，用一阶泰勒展开来近似目标函数，即：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/wzmDo6QVK4C5la1.png" alt="image-20210328180139838">，其中<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/R4mqvcxZz8tLgVI.png" alt="image-20210328180149902"></p>
<p>所以update rule就是：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/uHFcE76vP8kNq4e.png" alt="image-20210328180237799"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/FSz6JhQWxYUl19s.png" alt="image-20210328180403216"></p>
<p>即：<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/8C5J9hlUXinNMI3.png" alt="image-20210328180415645"></p>
<h3 id="Understanding-the-Updata-Rule"><a href="#Understanding-the-Updata-Rule" class="headerlink" title="Understanding the Updata Rule"></a>Understanding the Updata Rule</h3><p>作者指出这个update rule是covariant gradient descent的一个特殊形式。（covariant gradient descent 见[**Reference 3,4 **]）</p>
<p>TODO</p>
<h3 id="Obstacles-and-distance-fields"><a href="#Obstacles-and-distance-fields" class="headerlink" title="Obstacles and distance fields"></a>Obstacles and distance fields</h3><p>首先要说明：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/VbgYudDeNm6jAkx.png" alt="image-20210329110121142"></p>
<p>这里使用计算距离obstacle的方式是：**signed distance field d(x)**。这种方法对于计算static的环境是很有效的，其本质上就是需要提前计算空间中每一个点到最近障碍物的距离。d(x)  x为空间中一点，如果x在障碍物内部，d(x)为-1，外部d(x)为1，边界为0。计算d(x)的方法为：利用EDT(Euclidean Distance Transform)。</p>
<p>同时将机器人的身体简化为一些列圆（或简单图形），这样可以方便的计算安全距离。</p>
<p>有了这些，就可以得到**workspace potential function c(x)**，其用来penalizes points of the robot for being near obstacles.</p>
<p>例如：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/lieNG17wdTsHqpL.png" alt="image-20210328203712719"></p>
<p>或更平滑的：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/ApMm8kVDJ3hqT67.png" alt="image-20210328203731905"></p>
<h3 id="Defining-an-obstacle-potential"><a href="#Defining-an-obstacle-potential" class="headerlink" title="Defining an obstacle potential"></a>Defining an obstacle potential</h3><p>现在已经有了workspace potential function c(x)，这个c(x)是对于robot上一点的描述，而为了对整个机器人产生一个cost，就需要结合机器人各个位置的c(x)。最直接的方式就是对于时间积分，但这样可能会产生让机器人在障碍物区域高速移动的趋势。</p>
<p>所以选择使用</p>
<p>最终的loss为：其中u为机器人身上的一点，B为机器人全部位置的点集。本质上来讲是对workspace的arc-length做积分。积分只与速度项和workspace position有关。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/29/ck7UV6phyLiWSxm.png" alt="image-20210329104547832"></p>
<h3 id="Smooth-Projection-for-Joint-Limits"><a href="#Smooth-Projection-for-Joint-Limits" class="headerlink" title="Smooth Projection for Joint Limits"></a>Smooth Projection for Joint Limits</h3><p>一般处理joint limit的时候，有以下两种方法：本篇paper选用后者。</p>
<ol>
<li><p>额外加入一个potential term（作为罚项，防止joint value接近limit）</p>
</li>
<li><p>当违背极限时，project到安全的区域。</p>
</li>
</ol>
<p>这里的projection是关于A matrix的norm（A matrix定义在Covariant gradient descent这一小节中）。即：如果超过limit则截断至limit，然后乘上A的inverse。这个transform的作用是起到smooth的效果。</p>
<h2 id="Experiments-on-Robotic-Arm"><a href="#Experiments-on-Robotic-Arm" class="headerlink" title="Experiments on Robotic Arm"></a>Experiments on Robotic Arm</h2><p>稍微修改了Collision heuristic（即稍微修改了workspace potential function c(x)的计算方法），很核心的一个参数就是A矩阵的选取。</p>
<h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>L. Kavraki and J. Latombe. Probabilistic roadmaps for robot path planning. Practical Motion Planning in Robotics: Current Approaches and Future Directions, 53, 1998.</li>
<li>O. Brock and O. Khatib. Elastic Strips: A Framework for Motion Generation in Human Environments. The International Journal of Robotics Research, 21(12):1031, 2002.</li>
<li>J. A. Bagnell and J. Schneider. Covariant policy search. In Proceedings ofthe International Joint Conference on Artificial Intelligence (IJCAI), August 2003.</li>
<li>M. Zlochin and Y. Baram. Manifold stochastic dynamics for bayesian learning. Neural Comput., 13(11):2549–2572, 2001.</li>
</ol>
<h1 id="STOMP-Stochastic-trajectory-optimization-for-motion-planning"><a href="#STOMP-Stochastic-trajectory-optimization-for-motion-planning" class="headerlink" title="STOMP: Stochastic trajectory optimization for motion planning"></a>STOMP: Stochastic trajectory optimization for motion planning</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">阿翔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://canva4.github.io/2021/03/05/Mobile-Manipulator-Paper-Reading/">http://canva4.github.io/2021/03/05/Mobile-Manipulator-Paper-Reading/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://canVa4.github.io" target="_blank">Xiang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mobile-Manipulator/">Mobile Manipulator</a><a class="post-meta__tags" href="/tags/motion-planning/">motion planning</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/04/04/oFaeZwq1MDbLPiO.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/04/Note-for-OMPL-A-Primer/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2021/04/04/M7RP6sCeySfX9th.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Note for: OMPL-A Primer</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/07/RL-Pushing/"><img class="next-cover" data-lazy-src="https://i.loli.net/2021/01/28/V6ANwU5pyzWk4jS.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RL Pushing</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/27/Mobile-Manipulator-Intro-Resource/" title="Mobile Manipulator Intro & Resource"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2021/01/28/V6ANwU5pyzWk4jS.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2021-03-04</div><div class="relatedPosts_title">Mobile Manipulator Intro & Resource</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/04/Note-for-OMPL-A-Primer/" title="Note for: OMPL-A Primer"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2021/04/04/M7RP6sCeySfX9th.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2021-04-04</div><div class="relatedPosts_title">Note for: OMPL-A Primer</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 阿翔</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my Blog~</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({{ JSON.stringify(config) }});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="{{ src }}">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>